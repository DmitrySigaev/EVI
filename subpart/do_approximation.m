function do_aproximation(output_type, use_mask)
html = 0;
sep_leg = 1; % 26.04.2012 The goal:  make a chart with each legend aside (so not to obstruct the graph).

%load reaction
alpha = 0.01; % Significance level
%rstool(reactants,rate,'quadratic',alpha,xn,yn)
%nlintool(reactants,rate,@hougen,beta,0.01,xn,yn)


figure_1 = load (char(['mean_' char(output_type) '_evi3.mat'])); %generated by main.m
figure2 = figure_1.hgS_070000; %(mean_evi3.mat is mean_evi3.fig, that you sent for me.)
% we parse mean_evi3.fig for getting xdata and ydata


%pls indicate what the two lines below are doing: taking properties of
%YDATA generated form main.m and putting it in figure2???
ydata = figure2.children(1,1).children(1,1).properties.YData; % mean_EVI3
xdata = figure2.children(1,1).children(1,1).properties.XData; % DOY

if (size(xdata,2)<=22)
    disp(['Data is not enough: size: ', num2str(size(xdata,2)), ', min: ', num2str(min(xdata)), ' and max: ', num2str(max(xdata)),' of DOY']);
    return;
end

% our data correction -- ydata(8) is the EVI3@DOY_endpoint temporal interval 
ydata = data_correction(ydata);

% move_window_size is size in DOY points
% see article: http://gis.uml.edu/abrown2/ca/greenup/2003_zhang_etal/2003_zhang_etal.pdf
% paragraph: Before the NBAR EVI data could be fit to logistic functions
% described by Eq. (1).............

move_window_size = 10;
day_count = size(xdata,2); %count of total DOY period considered. ex. 365
circuit_capacity =  ceil(day_count/move_window_size); %365/8 = ca 46 ?



index_left_limit = ceil(move_window_size/4);
index_right_limit = floor(move_window_size*3/4);
vector_of_direction  = [ 0 0 ];

local_max_points = [ydata(1) 0.0 0.0 0.0 0.0 0.0 0.0];
local_min_points = [ydata(1) 1.0 1.0 1.0 1.0 1.0 1.0];
local_vector_direction = [0 0 0 0 0 0 0];
local_first_points = [1 0 0 0 0 0 0];
local_end_points = [1 0 0 0 0 0 0];
next_step = 0;

%% 
% 
% <<2.PNG>>
% 
 
%We can have different trajectory of vegetation index values with multiple
%growth periods described using several logistic models and therefore 
%we should detect where we have local minimums and 
%where we have local maximums in our trajectory.

%Commonly we have only one increasing period and one decreasing in the trajectory 

for i = 1: circuit_capacity;
    first_point = (i - 1) * move_window_size + 1;
    end_point = min(i * move_window_size, day_count);
    x_window = xdata(first_point:end_point); %select moving window 
    y_window = ydata(first_point:end_point); % EVI3 values from *.mat?
    [max_y_window, max_index] = max(y_window);
    [min_y_window, min_index] = min(y_window);
    c = max_y_window - min_y_window;
    d = min_y_window;
    
    if( (min_index <= index_left_limit) && (index_right_limit <= max_index))
        vector_of_direction(1) = vector_of_direction(2);
        vector_of_direction(2) = 1;

        disp(['smoothing function is increasing function in range [' int2str(xdata(first_point)) ', ' int2str(xdata(end_point)) ']'])
        if(min_y_window ~= ydata(first_point))
            disp(['range [' int2str(xdata(first_point)) ', ' int2str(xdata(end_point)) '] has local minimum in the DOY point : ' int2str(x_window(min_index))])
        end
        if(max_y_window ~= ydata(end_point))
            disp(['range [' int2str(xdata(first_point)) ', ' int2str(xdata(end_point)) '] has local maximum in the DOY point : ' int2str(x_window(max_index))])
        end
        
        if (vector_of_direction(1) ~= 1)
            next_step = next_step + 1;
            local_vector_direction(next_step) = 1;
            local_first_points(next_step) = first_point;
            if(next_step > 1) 
                local_end_points(next_step - 1) = first_point - 1;
            end
        end
    end
    
    if( max_index <= index_left_limit && index_right_limit <= min_index)
        vector_of_direction(1) = vector_of_direction(2);
        vector_of_direction(2) = -1;

        disp(['smoothing function is decreasing function in range [' int2str(xdata(first_point)) ', ' int2str(xdata(end_point)) ']'])
        if(min_y_window ~= ydata(end_point))
            disp(['range [' int2str(xdata(first_point)) ', ' int2str(xdata(end_point)) '] has local minimum in the DOY point : ' int2str(x_window(min_index))])
        end
        if(max_y_window ~= ydata(first_point))
            disp(['range [' int2str(xdata(first_point)) ', ' int2str(xdata(end_point)) '] has local maximum in the DOY point : ' int2str(x_window(max_index))])
        end
        
        if (vector_of_direction(1) ~= -1)
            next_step = next_step + 1;
            local_vector_direction(next_step) = -1;
            local_first_points(next_step) = first_point;
            if(next_step > 1) 
                local_end_points(next_step - 1) = first_point - 1;
            end
        end
    end
        
    if (local_min_points(next_step) >= min_y_window)
        local_min_points(next_step) = min_y_window;
    end
    if (local_max_points(next_step) <= max_y_window)
        local_max_points(next_step) = max_y_window;
    end   
    
end

local_end_points(next_step) = day_count;

if (html)
fig_name = ['trajectory of EVI 3 first stage']; 
figure('Name', fig_name);
plot(xdata, ydata,'k.', xdata(local_first_points(1:next_step)),ydata(local_first_points(1:next_step)), 'go', xdata(local_end_points(1:next_step)),ydata(local_end_points(1:next_step)), 'go'); 
%hold on
title('1. the separation trajectory of increasing and decreasing stage','Color','b')
ylabel('EVI');
xlabel('Day of the Julian Year');
end

for i = 1: next_step;
    x_window = xdata(local_first_points(i):local_end_points(i));
    y_window = ydata(local_first_points(i):local_end_points(i));
    [max_y_window, max_index] = max(y_window);
    [min_y_window, min_index] = min(y_window);
    if(i > 1)
       max_index = max_index + local_first_points(i) - 1; 
       min_index = min_index + local_first_points(i) - 1; 
    end
    if(local_vector_direction(i) == 1)
        if(i > 1 && i < next_step)
            local_first_points(i) = min_index;
            local_end_points(i - 1) = min_index;
            local_end_points(i) = max_index;
            local_first_points(i+1) = max_index;
        else
            if(i == 1)
                local_end_points(i) = max_index;
                local_first_points(i+1) = max_index;
            else
                local_first_points(i) = min_index;
                local_end_points(i-1) = min_index;
            end
        end
    end
    if(local_vector_direction(i) == -1)
        if(i > 1 && i < next_step)
            local_first_points(i) = max_index;
            local_end_points(i - 1) = max_index;
            local_end_points(i) = min_index;
            local_first_points(i+1) = min_index;
        else
            if(i == 1)
                local_end_points(i) = min_index;
                local_first_points(i+1) = min_index;
            else
                local_first_points(i) = max_index;
                local_end_points(i-1) = max_index;
            end
        end
    end
end

if (html)
fig_name = ['trajectory of EVI 3, second stage']; 
figure('Name', fig_name);
plot(xdata, ydata,'k.', xdata(local_first_points(1:next_step)),ydata(local_first_points(1:next_step)), 'go', xdata(local_end_points(1:next_step)),ydata(local_end_points(1:next_step)), 'go'); 
%hold on
title('2. the separation trajectory of increasing and decreasing stage. (elaboration)','Color','b')
ylabel('EVI');
xlabel('Day of the Julian Year');

% the separation trajectory of increasing and decreasing stage was done
end

%%

%central figure: generation of onset_points.fig 
if (sep_leg)
    fig_name = ['onset_points1_' char(output_type) '_leg.fig']; %initialization of output figure, yes
    if (html)
        figure('Name', fig_name);
    else
        fig = figure('Name', fig_name);
    end
else
    %begin: generation of onset_points.fig
    fig_name = ['onset_points_' char(output_type) '.fig']; %initialization of output figure 
    if (html)
        figure('Name', fig_name);
    else
        fig = figure('Name', fig_name);
    end
    subplot(3,1,1)
    %upper figure: generation of onset_points.fig 
end
plot(xdata, ydata,'-.r*')
hold on

for i = 1: next_step;
    x_window = xdata(local_first_points(i):local_end_points(i)); %select moving window 
    y_window = ydata(local_first_points(i):local_end_points(i)); % EVI3 values from *.mat   
    [max_y_window, max_index] = max(y_window);
    [min_y_window, min_index] = min(y_window);
    c = max_y_window - min_y_window;
    d = min_y_window;
% 15 is value of a and -0.1 value of b in logistic function- increasing
% part of logisitc curve
    if(local_vector_direction(i) == 1)
        betta0=[15 -0.1];   
        beta0=[15 -0.1 c d];  
    end
% 15 is value of a and 0.05 value of b in logistic function- decreasing
% part of logisitc curve   
    if(local_vector_direction(i) == -1)
        betta0 = [-15 0.05]; %decreasing evi3 curve to min = 0.101 or d
        beta0=[-15 0.05 c d];   
    end
% use here nlparci di estimate the confidence interval of the
% coefficients (maybe we can also visualize the CI)

%calculating the smoothing function
    smoothing = @(betta,xx) smoothing_fun_a_b(betta,xx,c,d); % y = c./(1+exp(a+b*x))+d;
    [betta,r,J_mt,COVB,mse]=nlinfit(x_window',y_window',smoothing,betta0');
    m1 = max(J_mt(:,1));
    m2 = max(J_mt(:,2));

%pls see nlinfit documentation nlinfit(X,y,fun,beta0,option) in option, you can specify 
%WgtFun = 'logistic' http://www.mathworks.com/help/toolbox/stats/nlinfit.html#inputarg_options
%for robust fits. Should we use it?
       
    if(m1 == 0 && m2 == 0)
        betta0(2) = betta0(2)*2;
        [betta,r,J_mt,COVB,mse]=nlinfit(x_window',y_window',smoothing,betta0');
    end
    
    ci_j = nlparci(betta,r,'Jacobian',J_mt);
    ci_c = nlparci(betta,r,'covar',COVB);

    [y_ci_c_window, delta_ci_c] = nlpredci(smoothing,x_window',betta,r,'cov',COVB);
    [y_ci_j_window, delta_ci_j] = nlpredci(smoothing,x_window',betta,r,'jacobian',J_mt);

    beta_ci_j_1 = [ci_j(1) ci_j(2) c d];
    beta_ci_j_2 = [ci_j(3) ci_j(4) c d];
    beta_ci_c_1 = [ci_c(1) ci_c(2) c d];
    beta_ci_c_2 = [ci_c(3) ci_c(4) c d];
    
    beta = [betta(1) betta(2) c d];
    save(i).beta = beta;
    save(i).beta_ci_j_1 = beta_ci_j_1;
    save(i).beta_ci_j_2 = beta_ci_j_2;
    save(i).beta_ci_c_1 = beta_ci_c_1;
    save(i).beta_ci_c_2 = beta_ci_c_2;
    save(i).y_ci_c_w = y_ci_c_window';
    save(i).y_ci_j_w = y_ci_j_window';
    save(i).delta_ci_c_w = delta_ci_c';
    save(i).delta_ci_j_w = delta_ci_j';
    
    y_sm_window = smoothing_fun(beta,x_window); % y = c./(1+exp(a+b*x))+d;
    
    R=corrcoef(y_window,y_sm_window);
    RMSE = sqrt(mse);
    
    integral = int_of_smooth_fun(beta,xdata(local_end_points(i))) - int_of_smooth_fun(beta,xdata(local_first_points(i)));


    disp(['a = ' num2str(beta(1)) '; b = ' num2str(beta(2)), '; c = ',num2str(beta(3)), '; d = ',num2str(beta(4))])
    
    disp(['---> RMSE ='  num2str(RMSE)]);
    disp(['---> MSE ='  num2str(mse)]);
    disp(['---> Integral ='  num2str(integral)]);


   % window aproximation
    if( bitand(i,1))   %what is supposed to do this if...end? not clear
        plot(x_window,smoothing_fun(beta,x_window),'--bo')
    else
        plot(x_window,smoothing_fun(beta,x_window),'--go')
    end    
    
end
hold off
legend('observed','approx 1','approx 2',...
        'Location','NorthEastOutside')
title('observed EVI and approximated EVI','Color','b')
ylabel('EVI');
xlabel('Day of the Julian Year');


%central figure: generation of onset_points.fig 
if (sep_leg)
    if (html)
        %nothing
    else
        %save on hard disk
        saveas(fig, fig_name);
        close(fig);
        clearvars fig
    end
    fig_name = ['onset_points2_' char(output_type) '_leg.fig']; %initialization of output figure, yes
    if (html)
        figure('Name', fig_name);
    else
        fig = figure('Name', fig_name);
    end
else
    %central figure: generation of onset_points.fig 
    subplot(3,1,2)
end


hold on
for i = 1: next_step;
    x_window = xdata(local_first_points(i):local_end_points(i)); %select moving window 
    y_window = ydata(local_first_points(i):local_end_points(i)); % EVI3 values from *.mat  
   % window aproximation
    if( bitand(i,1))   %what is supposed to do this if...end? not clear
        plot(x_window,k_fun(save(i).beta,x_window),'--bo')
    else
        plot(x_window,k_fun(save(i).beta,x_window),'--go')
    end    

end
legend('k_f_u_n',...
       'Location','NorthEastOutside')
xlabel('Day of the Julian Year');
hold off

    %bottom figure: generation of onset_points.fig 
if (sep_leg)
    if (html)
        %nothing
    else
        %save on hard disk
        saveas(fig, fig_name);
        close(fig);
        clearvars fig
    end
    fig_name = ['onset_points3_' char(output_type) '_leg.fig']; %initialization of output figure, yes
    if (html)
        figure('Name', fig_name);
    else
        fig = figure('Name', fig_name);
    end
else
    %bottom figure: generation of onset_points.fig 
    subplot(3,1,3)
end
hold on
l_i = 0; % legend_index
strArray = java_array('java.lang.String', 4);
for i = 1: next_step;
    x_window = xdata(local_first_points(i):local_end_points(i)); %select moving window 
    y_window = ydata(local_first_points(i):local_end_points(i)); % EVI3 values from *.mat 
    
   % window aproximation
    if( bitand(i,1))   %what is supposed to do this if...end? not clear
        plot(x_window,kr_fun(save(i).beta,x_window),'--bo')
    else
        plot(x_window,kr_fun(save(i).beta,x_window),'--go')
    end    
    if(local_vector_direction(i) == 1)
      lvd  = [ 0 0 ];
      next_m = 0;
      for  m = local_first_points(i):local_end_points(i)-1;
          y1 = kr_fun(save(i).beta,xdata(m))*100000;
          y2 = kr_fun(save(i).beta,xdata(m+1))*100000;
          if(y1 < y2)
             lvd(1) = lvd(2);
             lvd(2) = -1;
             if(lvd(1)~= -1)
                 next_m = next_m + 1;
                 min_index(next_m) = m;
                 %plot(xdata(m),kr_fun(save(i).beta,xdata(m)),'r*');
             end
          end
          if(y1 > y2)
             lvd(1) = lvd(2);
             lvd(2) = 1;
             if(lvd(1)~= 1)
                 next_m = next_m + 1;
                 max_index(next_m) = m;
                 if(next_m == 2)
                    plot(xdata(m),kr_fun(save(i).beta,xdata(m)),'r^');
                    l_i = l_i + 1;
                    strArray(l_i) = java.lang.String(['greenup onset: DOY = ' num2str(xdata(m))]);
                    disp(strArray(l_i));
                    days_save(1) = m;
                 end
                 if(next_m == 4)
                    l_i = l_i + 1;
                    plot(xdata(m),kr_fun(save(i).beta,xdata(m)),'rv');
                    strArray(l_i) =  java.lang.String(['maturity onset: DOY = ' num2str(xdata(m))]);
                    disp(strArray(l_i));
                    days_save(2) = m;
                 end
             end
          end
      end
    end
    if(local_vector_direction(i) == -1)
       lvd  = [ 0 0 ];
      next_m = 0;
      for  m = local_first_points(i):local_end_points(i)-1;
          y1 = kr_fun(save(i).beta,xdata(m))*100000;
          y2 = kr_fun(save(i).beta,xdata(m+1))*100000;
          if(y1 < y2)
             lvd(1) = lvd(2);
             lvd(2) = -1;
             if(lvd(1)~= -1)
                 next_m = next_m + 1;
                 min_index(next_m) = m;
                 if(next_m == 2)
                    l_i = l_i + 1;
                    plot(xdata(m),kr_fun(save(i).beta,xdata(m)),'mv');
                    strArray(l_i) =  java.lang.String(['senecence onset: DOY = ' num2str(xdata(m))]);
                    disp(strArray(l_i));
                    days_save(3) = m;
                 end
                 if(next_m == 4)
                    l_i = l_i + 1;
                    plot(xdata(m),kr_fun(save(i).beta,xdata(m)),'m^');
                    strArray(l_i) =  java.lang.String(['dormancy onset: DOY = ' num2str(xdata(m))]);
                    disp(strArray(l_i));
                    days_save(4) = m;
                 end
             end
          end
          if(y1 > y2)
             lvd(1) = lvd(2);
             lvd(2) = 1;
             if(lvd(1)~= 1)
                 next_m = next_m + 1;
                 max_index(next_m) = m;
              %   plot(xdata(m),kr_fun(save(i).beta,xdata(m)),'r*');
             end
          end
      end
    end
end

legend('k`_f_u_n_1', char(strArray(1)),char(strArray(2)), 'k`_f_u_n_2', char(strArray(3)), char(strArray(4)),...
       'Location','NorthEastOutside')
xlabel('Day of the Julian Year');
hold off

if (html)
% nothing
else
% seve on hard disk
saveas(fig, fig_name);
close(fig);
clearvars fig
end
%end: generation of onset_points.fig 
if (use_mask)
figure_w1 = load (char(['real_' char(output_type) '_area.mat'])); %generated by main.m
figure_w2 = figure_w1.hgS_070000; %(real_area.mat is real_area.fig, that you sent for me.)
% we parse real_area.fig for getting (DOY), (N18/A18), (A18), (N19/A19),(A19)
%Nx is number of pixel uses for EVI calculation

rdy_data1 = figure_w2.children(1,1).children(1,1).properties.YData; % (N18/A18) or acreage of crop for h18v04 , pls see main: real_acreage(DOY_NUM, tile_index) = N2/AllLand; % Good land / all land
rdy_data2 = figure_w2.children(1,1).children(2,1).properties.YData; % (N19/A19) or acreage of crop for h19v04
rdy_data3 = figure_w2.children(3,1).children(1,1).properties.YData; % (A18) number of land pixels for h18v04, pls see main:  land_area (DOY_NUM, tile_index) = AllLand; %  all land
rdy_data4 = figure_w2.children(3,1).children(2,1).properties.YData; % (A19) number of land pixels for h19v04
rdx_data = figure_w2.children(1,1).children(1,1).properties.XData; % DOY

% autocorrection: now it can  be deleted
rdy_data1 = data_correction(rdy_data1);% if all data are good then do nothing else do linear interpolation (DOY49)
rdy_data2 = data_correction(rdy_data2);
rdy_data3 = data_correction(rdy_data3);
rdy_data4 = data_correction(rdy_data4);

rdy_data_1 = rdy_data1.*rdy_data3; % N18/A18*A18 = N18
rdy_data_2 = rdy_data2.*rdy_data4;% N19/A19*A19 = N19
rdy_data34 = rdy_data3+rdy_data4; % A18 + A19
rdy_data12 = rdy_data_1+rdy_data_2; % N18 + N19
rdy_new = rdy_data12./rdy_data34; %N(18and19)/A(18and19)
end
%begin: generation of integrand.fig 
if (sep_leg)
    fig_name = ['integrand1_' char(output_type) '_leg.fig']; %initialization of output figure
    if (html)
        figure('Name', fig_name);
    else
        fig = figure('Name', fig_name);
    end
else
    fig_name = ['integrand_' char(output_type) '.fig']; %initialization of output figure
    if (html)
        figure('Name', fig_name);
    else
        fig = figure('Name', fig_name);
    end
    subplot(3,1,1)
end

%upper figure: generation of integrand.fig 
hold on

x_window_1 = xdata(local_first_points(1):local_end_points(1)-1); %select moving window without breaking point
y_window_1 = smoothing_fun(save(1).beta,x_window_1);

y_window_av = (smoothing_fun(save(1).beta, xdata(local_end_points(1))) + smoothing_fun(save(2).beta,xdata(local_first_points(2)))) / 2.0; % average 
x_window_av = (xdata(local_end_points(1)) + xdata(local_first_points(2))) / 2.0; % average 

x_window_2 = xdata(local_first_points(2) + 1:local_end_points(2)); %select moving window without breaking point
y_window_2 = smoothing_fun(save(2).beta,x_window_2);

y_smooth = [y_window_1, y_window_av, y_window_2];
x_smooth = [x_window_1, x_window_av, x_window_2];

t = (x_smooth == xdata); % Thus we establish an equivalence of xdata and x_smooth arrays.
zero_index = find(t == 0);
if(~isempty(zero_index))
    disp('error');
end
% window aproximation
    
plot(x_smooth ,y_smooth,'-.b', 'LineWidth', 2);

sz  = size(x_smooth,2);
dx_sx  =  (xdata(local_end_points(2)) - xdata(local_first_points(1)) + 1)./(local_end_points(2) - local_first_points(1) + 1);
integral_by_sum = sum(y_smooth)*dx_sx; % integral are calculated by the sum of block(rectangle area) under the smoothing_fun

sum_int_1 =(int_of_smooth_fun(save(1).beta,xdata(local_end_points(1))) - int_of_smooth_fun(save(1).beta,xdata(local_first_points(1))));
sum_int_2 =(int_of_smooth_fun(save(2).beta,xdata(local_end_points(2))) - int_of_smooth_fun(save(2).beta,xdata(local_first_points(2))));
integral_by_int = sum_int_1 + sum_int_2; %integral are calculated by the integration from  int_of_smooth_fun

epsilon = abs(integral_by_sum - integral_by_int);
if(epsilon >= dx_sx)
    disp('error: estimation is bad');
end
xdata_1 = xdata(1:days_save(1));
ydata_1 = ydata(1:days_save(1));
xdata_2 = xdata(days_save(1):days_save(2));
ydata_2 = ydata(days_save(1):days_save(2));
xdata_3 = xdata(days_save(2):days_save(3));
ydata_3 = ydata(days_save(2):days_save(3));
xdata_4 = xdata(days_save(3):size(xdata,2));
ydata_4 = ydata(days_save(3):size(xdata,2));

mmm = max(ydata)*1.2;
plot(xdata, ydata,'k.');



%plot(xdata_1, ydata_1,'--g', xdata_2, ydata_2,'--r', xdata_3, ydata_3,'-y', xdata_4, ydata_4,'-.m')
%plot(xdata(days_save(1)), ydata(days_save(1)),'ko', xdata(days_save(2)), ydata(days_save(2)),'ko', ...
%     xdata(days_save(3)), ydata(days_save(3)),'ko', xdata(days_save(4)), ydata(days_save(4)),'ko');
 
plot([xdata(days_save(1));xdata(days_save(1))], [0,mmm],'-', 'LineWidth', 2, 'Color',[0,1,0])
plot([xdata(days_save(2));xdata(days_save(2))], [0,mmm],'-', 'LineWidth', 2, 'Color',[1,1,0])
plot([xdata(days_save(3));xdata(days_save(3))], [0,mmm],'-', 'LineWidth', 2, 'Color',[0.3,0.5,0])
plot([xdata(days_save(4));xdata(days_save(4))], [0,mmm],'-', 'LineWidth', 2, 'Color',[0.5,0.5,0.5])

 
hold off
legend('approx EVI','observed EVI','greenup', 'maturity', 'senescence', 'dormancy',...
        'Location', 'NorthEastOutside')
title('observed EVI and approximated EVI','Color','b')
ylabel('EVI');
xlabel('Day of the Julian Year');

%central figure: generation of integrand.fig 
if (sep_leg)
    if (html)
        %nothing
    else
        %save on hard disk
        saveas(fig, fig_name);
        close(fig);
        clearvars fig
    end
    fig_name = ['integrand2_' char(output_type) '_leg.fig']; %initialization of output figure, yes
    if (html)
        figure('Name', fig_name);
    else
        fig = figure('Name', fig_name);
    end
else
    %central figure: generation of integrand.fig
    subplot(3,1,2) 
end

zerofun = @(x) (  x == 0 );
%ydata0 = zerofun(days_save(1):size(xdata,2));

%ydata_1 = [int_of_smooth_fun(save(1).beta,xdata(1:days_save(1))) - int_of_smooth_fun(save(1).beta,xdata(1)), zerofun(days_save(1)+1:size(xdata,2))];
%xdata_1 = [xdata(1:days_save(1)), xdata(days_save(1)+1:size(xdata,2))];

ydata_1_cut = [int_of_smooth_fun(save(1).beta,xdata(1:days_save(1))) - int_of_smooth_fun(save(1).beta,xdata(1))];
xdata_1_cut = [xdata(1:days_save(1))];

%ydata_2 = [zerofun(1:days_save(1)-1), int_of_smooth_fun(save(1).beta,xdata(days_save(1):days_save(2))) - int_of_smooth_fun(save(1).beta,xdata(days_save(1))),zerofun(days_save(2)+1:size(xdata,2))];

ydata_2_cut = [int_of_smooth_fun(save(1).beta,xdata(days_save(1):days_save(2))) - int_of_smooth_fun(save(1).beta,xdata(days_save(1)))];
xdata_2_cut = [xdata(days_save(1):days_save(2))];

%ydata_3 = [zerofun(1:days_save(2)-1), int_of_smooth_fun(save(2).beta,xdata(days_save(2):days_save(3))) - int_of_smooth_fun(save(2).beta,xdata(days_save(2))),zerofun(days_save(3)+1:size(xdata,2))];
ydata_3_cut = [int_of_smooth_fun(save(2).beta,xdata(days_save(2):days_save(3))) - int_of_smooth_fun(save(2).beta,xdata(days_save(2)))];
xdata_3_cut = [xdata(days_save(2):days_save(3))];

%ydata_4 = [zerofun(1:days_save(3)-1), int_of_smooth_fun(save(2).beta,xdata(days_save(3):size(xdata,2))) - int_of_smooth_fun(save(2).beta,xdata(days_save(3)))];
ydata_4_cut = [int_of_smooth_fun(save(2).beta,xdata(days_save(3):days_save(4))) - int_of_smooth_fun(save(2).beta,xdata(days_save(3)))];
xdata_4_cut = [xdata(days_save(3):days_save(4))];

ydata_5_cut = [int_of_smooth_fun(save(2).beta,xdata(days_save(4):size(xdata,2))) - int_of_smooth_fun(save(2).beta,xdata(days_save(4)))];
xdata_5_cut = [xdata(days_save(4):size(xdata,2))];

% white blank line (need resize)
x = 1:8:401;
area(x, zerofun(x),'FaceColor',[1,1,1],...
             'EdgeColor',[1,1,1],...
             'LineWidth',2)

hold on

% -------------------------------------
%plot(xdata, ydata_4, '--ko');
%area(xdata, ydata_4,'FaceColor','m',...
%               'EdgeColor','m',...
%              'LineWidth',2)
area(xdata_1_cut, ydata_1_cut,'FaceColor',[0.5,0.5,0.5],...
             'EdgeColor',[0.4,0.4,0.4],...
             'LineWidth',2)
%plot(xdata_4_cut, ydata_4_cut, '--ro');


% -------------------------------------

%area(xdata, ydata_1,'FaceColor','g',...
%             'EdgeColor','g',...
%             'LineWidth',2)
%plot(xdata, ydata_1, '--go');

area(xdata_2_cut, ydata_2_cut,'FaceColor',[0,1,0],...
             'EdgeColor',[0,0.9,0],...
             'LineWidth',2)
%plot(xdata_1_cut, ydata_1_cut, '--go');
%hold on

% -------------------------------------
%plot(xdata, ydata_2, '--ro');
%area(xdata, ydata_2,'FaceColor','r',...
%               'EdgeColor','r',...
%               'LineWidth',2)


area(xdata_3_cut, ydata_3_cut,'FaceColor',[1,1,0],...
             'EdgeColor',[0.9,0.9,0],...
             'LineWidth',2)
%plot(xdata_2_cut, ydata_2_cut, '--ro');

% -------------------------------------
%plot(xdata, ydata_3, '--bo');
%area(xdata, ydata_3,'FaceColor','y',...
%               'EdgeColor','y',...
%               'LineWidth',2)

area(xdata_4_cut, ydata_4_cut,'FaceColor',[0.3,0.5,0],...
             'EdgeColor',[0.2,0.4,0],...
             'LineWidth',2)
%plot(xdata_3_cut, ydata_3_cut, '--ro');
% -------------------------------------
%plot(xdata, ydata_4, '--ko');
%area(xdata, ydata_4,'FaceColor','m',...
%               'EdgeColor','m',...
%              'LineWidth',2)
area(xdata_5_cut, ydata_5_cut,'FaceColor',[0.5,0.5,0.5],...
             'EdgeColor',[0.4,0.4,0.4],...
             'LineWidth',2)
%plot(xdata_4_cut, ydata_4_cut, '--ro');
legend('', 'D - dormancy', 'G - greenup','M - maturity', 'S - senescence', ...
       'Location','NorthEastOutside')
ylabel('integrand');     
cron_a_1 =  int_of_smooth_fun(save(1).beta,xdata(days_save(1))) - int_of_smooth_fun(save(1).beta,xdata(1));
integral_by_sum_1 = sum(y_smooth(1:days_save(1)))*dx_sx; % integral are calculated by the sum of block(rectangle area) under the smoothing_fun

total = integral_by_int; 
str1(1) = {'\uparrow'}; 
%str1(2) = {['dormancy/total:', num2str((round(cron_a_1/total*100)), '%3.0f'),'%']};
str1(2) = {['D/Tot.:', num2str((round(cron_a_1/total*100)), '%3.0f'),'%']};
text(xdata(days_save(1))/2.0,0,str1,'HorizontalAlignment','center', 'VerticalAlignment','Top')

cron_a_2 =  int_of_smooth_fun(save(1).beta,xdata(days_save(2))) - int_of_smooth_fun(save(1).beta,xdata(days_save(1)));
integral_by_sum_2 = sum(y_smooth(days_save(1):days_save(2)))*dx_sx; % integral are calculated by the sum of block(rectangle area) under the smoothing_fun

str2(1) = {'\uparrow'};
%str2(2) = {['greenup/total:', num2str((round(cron_a_2/total*100)), '%3.0f'),'%']};
str2(2) = {['G/Tot.:', num2str((round(cron_a_2/total*100)), '%3.0f'),'%']};
text((xdata(days_save(2)) + xdata(days_save(1)))/2.0,0,str2,'HorizontalAlignment','center', 'VerticalAlignment','Top')

cron_a_3 =  int_of_smooth_fun(save(2).beta,xdata(days_save(3))) - int_of_smooth_fun(save(1).beta,xdata(days_save(2)));
integral_by_sum_3 = sum(y_smooth(days_save(2):days_save(3)))*dx_sx; % integral are calculated by the sum of block(rectangle area) under the smoothing_fun

str3(1) = {'\uparrow'};
%str3(2) = {['maturity/total:', num2str((round(cron_a_3/total*100)), '%3.0f'),'%']};
str3(2) = {['M/Tot.:', num2str((round(cron_a_3/total*100)), '%3.0f'),'%']};
text((xdata(days_save(3)) + xdata(days_save(2)))/2.0,0,str3,'HorizontalAlignment','center', 'VerticalAlignment','Top')

cron_a_4 =  int_of_smooth_fun(save(2).beta,xdata(days_save(4))) - int_of_smooth_fun(save(2).beta,xdata(days_save(3)));
integral_by_sum_4 = sum(y_smooth(days_save(3):days_save(4)))*dx_sx; % integral are calculated by the sum of block(rectangle area) under the smoothing_fun

str4(1) = {'\uparrow'};
%str4(2) = {['senescence/total:', num2str((round(cron_a_4/total*100)), '%3.0f'),'%']};
str4(2) = {['S/Tot.', num2str((round(cron_a_4/total*100)), '%3.0f'),'%']};
text((xdata(days_save(4)) + xdata(days_save(3)))/2.0,0,str4,'HorizontalAlignment','center', 'VerticalAlignment','Top')


cron_a_5 =  int_of_smooth_fun(save(2).beta,xdata(size(xdata,2))) - int_of_smooth_fun(save(2).beta,xdata(days_save(4)));
integral_by_sum_5 = sum(y_smooth(days_save(4):size(xdata,2)))*dx_sx; % integral are calculated by the sum of block(rectangle area) under the smoothing_fun

str5(1) = {'\uparrow'};
%str5(2) = {['dormancy/total:', num2str((round(cron_a_5/total*100)), '%3.0f'),'%']};
str5(2) = {['D/Tot.:', num2str((round(cron_a_5/total*100)), '%3.0f'),'%']};
text((xdata(size(xdata,2)) + xdata(days_save(4)))/2.0,0,str5,'HorizontalAlignment','center', 'VerticalAlignment','Top')

if 0
str6(1) = {'G - greenup'};
str6(2) = {'M - maturity'};
str6(3) = {'S - senescence'};
str6(4) = {'D - dormancy'};

text(10,40, str6,...
 'HorizontalAlignment','Left',... 
 'EdgeColor',[0 0 0],...
 'BackgroundColor',[1 1 1],...
 'Selected', 'on',...
 'SelectionHighlight', 'on',...
 'Margin',10);
end

if (sep_leg)
    if (html)
        %nothing
    else
        %save on hard disk
        saveas(fig, fig_name);
        close(fig);
        clearvars fig
    end
    fig_name = ['integrand3_' char(output_type) '_leg.fig']; %initialization of output figure, yes
    if (html)
        figure('Name', fig_name);
    else
        fig = figure('Name', fig_name);
    end
else
    %bottom figure: generation of integrand.fig
    subplot(3,1,3) 
end

if(use_mask)
bar(rdx_data, rdy_new.*100,0.5,'g')
ylabel('EVI area/a total crop area, %');
legend('crop',...
       'Location','NorthEastOutside')

   disp('the value of each bar of the histogram:');
   disp(rdy_new.*100);
end   

if (html)
%nothing
else
    % save on hard disk
    saveas(fig, fig_name);
    close(fig);
    clearvars fig
end
%end: generation of integrand.fig 

%begin: generation of conf_interval_param.fig
fig_name = ['conf_interval_param_' char(output_type) '.fig']; %initialization of output figure 
if (html)
figure('Name', fig_name);
else
fig = figure('Name', fig_name);
end

y_window_1_ci_c_1 = smoothing_fun(save(1).beta_ci_c_1,x_window_1);
y_window_av_ci_c_1 = (smoothing_fun(save(1).beta_ci_c_1, xdata(local_end_points(1))) + smoothing_fun(save(2).beta_ci_c_1,xdata(local_first_points(2)))) / 2.0; % average 
y_window_2_ci_c_1 = smoothing_fun(save(2).beta_ci_c_1,x_window_2);
y_smooth_ci_c_1 = [y_window_1_ci_c_1, y_window_av_ci_c_1, y_window_2_ci_c_1];

y_window_1_ci_c_2 = smoothing_fun(save(1).beta_ci_c_2,x_window_1);
y_window_av_ci_c_2 = (smoothing_fun(save(1).beta_ci_c_2, xdata(local_end_points(1))) + smoothing_fun(save(2).beta_ci_c_2,xdata(local_first_points(2)))) / 2.0; % average 
y_window_2_ci_c_2 = smoothing_fun(save(2).beta_ci_c_2,x_window_2);
y_smooth_ci_c_2 = [y_window_1_ci_c_2, y_window_av_ci_c_2, y_window_2_ci_c_2];

verts = [x_smooth, x_smooth; y_smooth_ci_c_1, y_smooth_ci_c_2]';
faces = [(1:1:46), (92:-1:47)];


patch('Faces',faces,'Vertices',verts,'FaceColor',[0.9 0.9 0.9]);
hold on
plot(x_smooth ,y_smooth,'-.b', 'LineWidth', 2);
%plot(x_smooth ,y_smooth_ci_c_1,'-g', 'LineWidth', 2);
%plot(x_smooth ,y_smooth_ci_c_2,'-r', 'LineWidth', 2);
plot(x_smooth ,y_smooth_ci_c_1,'-','Color',[0.8,0.8,0.8], 'LineWidth', 2);
plot(x_smooth ,y_smooth_ci_c_2,'-','Color',[0.8,0.8,0.8], 'LineWidth', 2);

plot(xdata, ydata,'k.');
hold off
legend('ci ar','aprox', 'ci1', 'ci2', 'observed',...
       'Location','NorthEastOutside')
if (html)
%nothing
else
%save on hard disk
saveas(fig, fig_name);
close(fig);
clearvars fig
end
%end: generation of conf_interval_param.fig

%begin: generation of conf_interval.fig
fig_name = ['conf_interval_' char(output_type) '.fig']; %initialization of output figure 
if (html)
figure('Name', fig_name);
else
fig = figure('Name', fig_name);
end

y_window_1_ci_c = save(1).y_ci_c_w(1:local_end_points(1)-1);
y_window_av_ci_c = (save(1).y_ci_c_w(local_end_points(1)) + save(2).y_ci_c_w(1)) / 2.0; % average 
y_window_2_ci_c = save(2).y_ci_c_w(2:size(save(2).y_ci_c_w,2));
y_smooth_ci_c = [y_window_1_ci_c, y_window_av_ci_c, y_window_2_ci_c];

delta_1_ci_c = save(1).delta_ci_c_w(1:local_end_points(1)-1);
delta_av_ci_c = (save(1).delta_ci_c_w(local_end_points(1)) + save(2).delta_ci_c_w(1)) / 2.0; % average 
delta_2_ci_c = save(2).delta_ci_c_w(2:size(save(2).delta_ci_c_w,2));
delta_smooth_ci_c = [delta_1_ci_c, delta_av_ci_c, delta_2_ci_c];

verts = [x_smooth, x_smooth; y_smooth_ci_c-delta_smooth_ci_c, y_smooth_ci_c+delta_smooth_ci_c]';
faces = [(1:1:46), (92:-1:47)];


patch('Faces',faces,'Vertices',verts,'FaceColor',[0.8 0.8 0.8], 'LineStyle','--');
hold on
plot(x_smooth ,y_smooth,'-.b', 'LineWidth', 2);
%plot(x_smooth ,y_smooth_ci_c+delta_smooth_ci_c,'-g', 'LineWidth', 2);
%plot(x_smooth ,y_smooth_ci_c-delta_smooth_ci_c,'-r', 'LineWidth', 2);
plot(xdata, ydata,'k.');
hold off
%legend('ci ar','aprox', 'ci1', 'ci2', 'observed',...
%       'Location','NW')
legend('ci ar','aprox', 'observed',...
       'Location','NorthEastOutside')
if (html)
%nothing
else
%save on hard disk
saveas(fig, fig_name);
close(fig);
clearvars fig
end
%end: generation of conf_interval.fig